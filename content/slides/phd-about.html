<!DOCTYPE html>
<html>
  <head>
    <title>PhD about</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Open+Sans:400,700,800);
      @import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Fira+Mono:400,700,400italic);

      body {
        font-family: 'Source Sans Pro';
        font-weight: 400
        font-size: 23px;
      }

      .remark-slide-content {
        font-size: 23px;
        background-color: #fdf8ea;
      }

      .remark-slide-scaler {
        -moz-box-shadow: 0 !important;
        -webkit-box-shadow: 0 !important;
        box-shadow: 0 !important;
      }

      .remark-slide-number {
        font-family: 'Open Sans';
        font-weight: bold;
      }

      h1, h2, h3 {
        font-family: 'Open Sans', sans-serif;
        font-weight: 700;
        line-height: 1.5;
        word-spacing: .1em;
      }

      .red { color: #dc143c; }
      .orange { color: :#f56b00; }
      .bold { font-weight: bold; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }

      .remark-code, .remark-inline-code { font-family: 'Fira Mono'; }

      li {
        margin-top: 16px;
      }

       /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2 {
        font-size: 28px;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Relations */
      .tg  {border-collapse:collapse;border-spacing:0;}
      .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
      .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
      .tg .tg-fymr{font-weight:bold;border-color:inherit;text-align:left;vertical-align:top}
      .tg .tg-6tgj{color:#f56b00;text-align:left;vertical-align:top;font-weight:bold;}
      .tg .tg-7tgj{color:#389638;text-align:left;vertical-align:top;font-weight:bold;}
      .tg .tg-lolk{background-color:#e6e6fa;text-align:left;vertical-align:top}
      .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
    </style>
  </head>
  <body>
    <textarea id="source">

name: phd
class: center, middle

# PhD presentation

## Statistical learning for large-scale query optimisation

### Max Halford

<div>
  <img src="/img/slides/phd-about/irit.png" width=140 height=140 />
  <img src="/img/slides/phd-about/imt.jpg" width=140 height=140 style="padding-left: 40px;" />
</div>

---

## Outline

1. Relational databases in a nutshell
2. Problem formulation
3. How Bayesian networks fit in
4. Future goals

---

## Brief introduction

- Second year PhD student
- Working between IRIT and IMT
- Supervisors are Frank Morvan (IRIT) and Philippe Saint Pierre (IMT)
- PhD topics: relational databases, query optimization, unsupervised learning, Bayesian networks

---

## Relational databases

<div style="display: flex; flex-direction: row; align-items: center; justify-content: space-between;">

  <table class="tg">
    <caption style="margin-bottom: 10px;">Customers</caption>
    <tr>
      <th class="tg-fymr">id</th>
      <th class="tg-fymr">name</th>
      <th class="tg-fymr">age</th>
      <th class="tg-fymr">nationality</th>
    </tr>
    <tr>
      <td class="tg-6tgj">1</td>
      <td class="tg-0pky">Théo</td>
      <td class="tg-0pky">23</td>
      <td class="tg-0pky">French</td>
    </tr>
    <tr>
      <td class="tg-6tgj">2</td>
      <td class="tg-0pky">Jack</td>
      <td class="tg-0pky">23</td>
      <td class="tg-0pky">British</td>
    </tr>
    <tr>
      <td class="tg-6tgj">3</td>
      <td class="tg-0pky">Roger</td>
      <td class="tg-0pky">66</td>
      <td class="tg-0pky">British</td>
    </tr>
  </table>

  <table class="tg">
    <caption style="margin-bottom: 10px;">Sales</caption>
    <tr>
      <th class="tg-fymr">customer_id</th>
      <th class="tg-fymr">shop_id</th>
      <th class="tg-fymr">date</th>
    </tr>
    <tr>
      <td class="tg-6tgj">1</td>
      <td class="tg-7tgj">1</td>
      <td class="tg-0pky">2018/08/05</td>
    </tr>
    <tr>
      <td class="tg-6tgj">1</td>
      <td class="tg-7tgj">1</td>
      <td class="tg-0pky">2018/08/12</td>
    </tr>
    <tr>
      <td class="tg-6tgj">1</td>
      <td class="tg-7tgj">1</td>
      <td class="tg-0pky">2018/08/19</td>
    </tr>
    <tr>
      <td class="tg-6tgj">3</td>
      <td class="tg-7tgj">2</td>
      <td class="tg-0pky">2018/08/04</td>
    </tr>
    <tr>
      <td class="tg-6tgj">3</td>
      <td class="tg-7tgj">2</td>
      <td class="tg-0pky">2018/08/11</td>
    </tr>
    <tr>
      <td class="tg-6tgj">3</td>
      <td class="tg-7tgj">2</td>
      <td class="tg-0pky">2018/08/18</td>
    </tr>
    <tr>
      <td class="tg-6tgj">2</td>
      <td class="tg-7tgj">1</td>
      <td class="tg-0pky">2017/09/11</td>
    </tr>
    <tr>
      <td class="tg-6tgj">2</td>
      <td class="tg-7tgj">2</td>
      <td class="tg-0pky">2018/07/23</td>
    </tr>
  </table>

  <table class="tg">
    <caption style="margin-bottom: 10px;">Stores</caption>
    <tr>
      <th class="tg-fymr">id</th>
      <th class="tg-fymr">name</th>
      <th class="tg-fymr">country</th>
    </tr>
    <tr>
      <td class="tg-7tgj">1</td>
      <td class="tg-0pky">Lidl</td>
      <td class="tg-0pky">France</td>
    </tr>
    <tr>
      <td class="tg-7tgj">2</td>
      <td class="tg-0pky">Tesco</td>
      <td class="tg-0pky">Britain</td>
    </tr>
  </table>

</div>

---

## The SQL language

- SQL is a language to query relational databases
- Users express queries in a logical way
- Users don't care how the query is processed, they just want an answer

```sql
SELECT
  stores.name, customers.name, sales.date
FROM
  stores, customers, sales
WHERE
  -- Filters
  stores.country = 'France' AND
  customers.nationality = 'French' AND
  customers.age > 42 AND
  -- Joins
  sales.shop_id = stores.id AND
  sales.customer_id = customers.id
```

---

## Query processing

A query $Q$ goes through the following processing phases:

1. A parser verifies that $Q$ is syntactically correct
2. $Q$ is converted to a **logical query plan** $L$
3. The query optimiser converts $L$ to a **physical execution plan** $P$
4. The query execution engine applies $P$ and streams back the results

My PhD is about part 3.

---

## Relational algebra

A logical query plan $L$ is composed of the following relational operators .red.bold[*]

1. $\sigma_A(R)$ to filter the rows of a relation $R$ based on a predicate $A$
2. $\pi_{a_1, \dots, a_n}(R)$ to select attributes $a_1, \dots, a_n$ of a relation $R$
3. $R_1 \bowtie R_2$ to join two relations $R_1$ and $R_2$

For example:

$$L = \sigma\_{nationality = ``French"}(customers) \bowtie \pi\_{date}(sales)$$

.footnote[.red.bold[*] Other relational operators exist but they are out of scope]

---

.left-column[
  ## Selection
]

.right-column[

#### With relational operators

$$\sigma_{age = 23}(customers)$$

#### Graphically

<table class="tg">
  <tr>
    <th class="tg-fymr">id</th>
    <th class="tg-fymr">name</th>
    <th class="tg-fymr">age</th>
    <th class="tg-fymr">nationality</th>
  </tr>
  <tr>
    <td class="tg-lolk">1</td>
    <td class="tg-lolk">Théo</td>
    <td class="tg-lolk">23</td>
    <td class="tg-lolk">French</td>
  </tr>
  <tr>
    <td class="tg-lolk">2</td>
    <td class="tg-lolk">Jack</td>
    <td class="tg-lolk">23</td>
    <td class="tg-lolk">British</td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">Roger</td>
    <td class="tg-0pky">66</td>
    <td class="tg-0pky">British</td>
  </tr>
</table>

]

---

.left-column[
  ## Selection
  ## Projection
]

.right-column[

#### With relational operators

$$\pi_{age,nationality}(customers)$$

#### Graphically

<table class="tg">
  <tr>
    <th class="tg-fymr">id</th>
    <th class="tg-fymr">name</th>
    <th class="tg-fymr">age</th>
    <th class="tg-fymr">nationality</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">Théo</td>
    <td class="tg-lolk">23</td>
    <td class="tg-lolk">French</td>
  </tr>
  <tr>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">Jack</td>
    <td class="tg-lolk">23</td>
    <td class="tg-lolk">British</td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">Roger</td>
    <td class="tg-lolk">66</td>
    <td class="tg-lolk">British</td>
  </tr>
</table>

]

---

.left-column[
  ## Selection
  ## Projection
  ## Join
]

.right-column[

#### With relational operators

$$customers \bowtie sales$$

#### Graphically

<table class="tg">
  <tr>
    <th class="tg-fymr">name</th>
    <th class="tg-fymr">age</th>
    <th class="tg-fymr">nationality</th>
    <th class="tg-fymr">customer_id</th>
    <th class="tg-fymr">shop_id</th>
    <th class="tg-fymr">date</th>
  </tr>
  <tr>
    <td class="tg-0pky">Théo</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">French</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">2018/08/05</td>
  </tr>
  <tr>
    <td class="tg-0pky">Théo</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">French</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">2018/08/12</td>
  </tr>
  <tr>
    <td class="tg-0pky">Théo</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">French</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">2018/08/19</td>
  </tr>
  <tr>
    <td class="tg-0pky">Théo</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">French</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2018/08/04</td>
  </tr>
  <tr>
    <td class="tg-0pky">Roger</td>
    <td class="tg-0pky">66</td>
    <td class="tg-0pky">British</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2018/08/11</td>
  </tr>
  <tr>
    <td class="tg-0pky">Roger</td>
    <td class="tg-0pky">66</td>
    <td class="tg-0pky">British</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2018/08/18</td>
  </tr>
  <tr>
    <td class="tg-0pky">Jack</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">British</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">2017/09/11</td>
  </tr>
  <tr>
    <td class="tg-0pky">Jack</td>
    <td class="tg-0pky">23</td>
    <td class="tg-0pky">British</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2018/07/23</td>
  </tr>
</table>

]

---

## Physical query plans

- A relational operator can be implemented with different algorithms, called **physical operators**
- For example there are:
 - Nested loop joins
 - Hash joins
 - Merge-sort joins
- No free lunch: the best physical operator depends on the input relation(s)
- For each logical query plan there are many physical query plans

---

## Physical query plan example

<div align="center">
  <img src="/img/slides/phd-about/physical_plan.png" height=460 />
</div>

---

## Query optimisation

- Relational operators have symmetric properties, such as
  - Commutativity: $\sigma_A(\sigma_B(R))=\sigma_B(\sigma_A(R))$
  - Distributivity: $\sigma_A(R_1 \bowtie R_2)=\sigma_A(R_1) \bowtie \sigma_A(R_2)$
- For each query there are many possible physical plans
- Each physical plan has a cost (usually time)
- Goal: use the plan with the lowest cost
- Problems
  - The number of plans to evaluate grows superexponentially
  - We only have a few hundreds of milliseconds to spend

---

## Cost model

- The cost of a query execution plan depends on
  1. The physical operators used to implement each relational operator
  2. The hardware (I/O speed, RAM amount, disk type)
  3. The statistical properties of the data
- The physical operator of a physical operator depends on the **cardinality** of the input relation(s)
- The cardinality of a relation is it's number of rows
- Cardinality estimation errors are the main source of error in query optimisation

---

## Cardinality estimation

- The cardinality of each base relation is easy to know
- Cardinality estimation is difficult for **intermediate results**, for example
  - What is the cardinality of $\sigma_A(R)$?
  - What is the cardinality of $R_1 \bowtie R_2$?
  - What is the cardinality of $\sigma_A(R_1) \bowtie \sigma_B(R_1)$? (hard)
- We only know the cardinality of an operator's output once it is has been executed
- We need prior estimates in order to perform optimisation

---

## Estimating selection cardinalities

- For $\sigma_{X=x}(R)$ (mono-attribute condition) then we can use a histogram
  - Low time complexity
  - Low space complexity
  - Tunable accuracy (change the number of bins)
- What about $\sigma_{X=x \land Y=y}(R)$?
  - If $X \perp Y$ then $P(X=x, Y=y) = P(X=x) \times P(Y=y)$
  - In practice $X$ and $Y$ are dependent, so what do we do?

---

## State of the art

- Better histograms (without handling dependencies)
- Multi-dimensional histograms
  - NP-hard to build
  - Exponential space complexity
- Sampling relations
  - Elegant solution, but high time complexity
  - Requires storing the samples or building them in real-time
- Bayesian networks
  - High time complexity without structural constraints
  - Existing proposals require many joins

---

## Bayesian networks

$$P(X_1, X_2, X_3, X_4, X_5) \simeq P(X_1) P(X_1 | X_2) P(X_3 | X_1) P(X_4 | X_3) P(X_5 | X_3)$$

<div align="center">
  <img src="/img/slides/phd-about/bayesian_network.png" height=400 />
</div>

---

## Inference over networks

- Exact inference
  - **Variable elimination**
  - Belief propagation
  - Junction tree
- Approximate Inference
  - Loopy belief propagation
  - MCMC methods
  - Variational methods

---

## Bayesian networks structure learning (BNSL)

- Score and search (e.g. BIC with MCMC)
  - Topological order-search
  - MCMC
  - Genetic algorithms
- Constraint-based approach
- **Chow-Liu trees**
- $k$-trees
- Integer linear programming

---

## Approximate conditional distributions (1)

<div align="center">

<table class="tg">
  <tr>
    <th class="tg-fymr"></th>
    <th class="tg-fymr">Carrefour</th>
    <th class="tg-fymr">Lidl</th>
    <th class="tg-fymr">...</th>
    <th class="tg-fymr">7-eleven</th>
  </tr>
  <tr>
    <td class="tg-fymr">France</td>
    <td class="tg-0pky">0.3</td>
    <td class="tg-0pky">0.1<br></td>
    <td class="tg-0pky">...</td>
    <td class="tg-0pky">0.001<br></td>
  </tr>
  <tr>
    <td class="tg-fymr">Germany</td>
    <td class="tg-0pky">0.01</td>
    <td class="tg-0pky">0.4</td>
    <td class="tg-0pky">...<br></td>
    <td class="tg-0pky">0</td>
  </tr>
  <tr>
    <td class="tg-fymr">...</td>
    <td class="tg-0pky">...</td>
    <td class="tg-0pky">...</td>
    <td class="tg-0pky">...</td>
    <td class="tg-0pky">...</td>
  </tr>
  <tr>
    <td class="tg-fymr">Japan</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">...</td>
    <td class="tg-0pky">0.3<br></td>
  </tr>
</table>

<p>A full representation of a CPD takes up a lot of space</p>

</div>

---

## Approximate conditional distributions (2)

<div align="center">

<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-fymr">Carrefour</th>
    <th class="tg-fymr">Lidl</th>
    <th class="tg-fymr">7-eleven</th>
    <th class="tg-fymr">[Auchan, Casino]</th>
    <th class="tg-fymr">[Intermarché, ]</th>
  </tr>
  <tr>
    <td class="tg-fymr">France</td>
    <td class="tg-0pky">0.3</td>
    <td class="tg-0pky">0.1<br></td>
    <td class="tg-0pky">0.001<br></td>
    <td class="tg-0pky">10<br></td>
    <td class="tg-0pky">20</td>
  </tr>
  <tr>
    <td class="tg-fymr">Germany</td>
    <td class="tg-0pky">0.01</td>
    <td class="tg-0pky">0.4</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">8<br></td>
  </tr>
  <tr>
    <td class="tg-fymr">Japan</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0.3</td>
    <td class="tg-0pky">4<br></td>
    <td class="tg-0pky">19</td>
  </tr>
  <tr>
    <td class="tg-fymr">[Albania, Zimbabwe]</td>
    <td class="tg-0pky">0.3</td>
    <td class="tg-0pky">0.2</td>
    <td class="tg-0pky">0.1</td>
    <td class="tg-0pky">9</td>
    <td class="tg-0pky">7<br></td>
  </tr>
</table>

<p>We can group non-frequent values into equi-height buckets</p>

</div>

---

## Approach

- Build one Bayesian network per relation
- Assume independence between relations
- Computational tricks make the approach very scalable
- Paper has been submitted to COMADS'19
- A working prototype will be released on GitHub

---

## Current research

1. Build "top-level trees" to capture dependencies accross relations
2. Compute distributions instead of point estimates

Stay tuned!

---


class: center, middle

# Thanks for listening

Slideshow made with [remark.js](https://remarkjs.com)


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/javascript">
      var slideshow = remark.create({

        // Customize slide number label, either using a format string..
        slideNumberFormat: 'Slide %current% of %total%',
        // .. or by using a format function
        slideNumberFormat: function (current, total) {
          return current;
        },

      });

      MathJax.Hub.Config({
        tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
          inlineMath: [ ['$','$'] ]
        },
        CommonHTML: {
          scale: 130
        }
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>
